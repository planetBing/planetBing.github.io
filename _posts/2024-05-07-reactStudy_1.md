---
layout: post
title: "리액트 컴포넌트와 렌더링 방법"
---

## 클래스 컴포넌트와 함수 컴포넌트

- 원래의 함수 컴포넌트는 별다른 생명주기 메서드나 상태가 필요 없이 렌더만 하는 경우에 제한적으로 사용
- 클래스 컴포넌트의 생명주기에는 무엇이 있는지?
  - 마운트: 컴포넌트가 생성되는 시점
  - 업데이트: 이미 생성된 컴포넌트의 내용이 변경되는 시점
  - 언마운트: 컴포넌트가 더 이상 존재하지 않는 시점
- 함수 컴포넌트는 state를 함수가 아닌 클로저에 저장해 두므로 함수가 다시 실행돼도 해당 state를 잃지 않고 다시 보여줄 수 있게 된다.
- 함수 컴포넌트에는 생명주기 메서드가 존재하지 않는다.
- useEffect 훅을 통해 클래스 컴포넌트의 생명주기 메서드인 componentDidMount, componentDidUpdate, componentWillUnmount를 비슷하게 구현할 수 있다.

## 렌더링은 어떻게 일어나는가?

[렌더링의 정의]

- 브라우저가 렌더링에 필요한 DOM 트리를 만드는 것

[렌더링이 일어나는 이유]

- 최초 렌더링: 사용자가 처음 앱에 진입했을 때
- 리렌더링 : 최초 렌더링 발생한 이후 발생하는 모든 렌더링
  - 클래스 컴포넌트에는 setState, forceUpdate
  - 함수 컴포넌트에서는 useState() 의 setter, useReducer()의 dispatch, 컴포넌의 key Props가 변경되는 경우
  - props가 변경되는 경우
- key는 왜 필요할까?
  - key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값.
  - current 트리와 workInProgress 트리 사이에서 어떠한 컴포넌트가 변경이 있었는지 구별하는데, 이 두 트리 사에서 같은 컴포넌트인지를 구별하는 값이 key.
  - 리렌더링이 필요한 컴포넌트를 최소화해야 하기 때문에 반드시 필요한 작업
- mobX와 리덕스 라이브럴리는 어디선가 각자의 방법으로 상태를 관리해주지만 이 상태 관리가 리액트의 리렌더링으로 이루어지지는 않음

[렌더와 커밋]

- 렌더 단계: 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업으로 렌더링 프로세스에서 컴포넌트를 실행해 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계
  → 비교하는 건 크게 type, props, key
- 커밋 단계: 렌더단계의 변경사항을 사용자에게 보여주는 단계
- 중요한 것은 리액트의 렌더링이 일어난다고 해서 무조건 DOM업데이트가 일어나는 것이 아님
